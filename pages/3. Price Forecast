import pandas as pd
import os
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
from google.colab import files
import io

def seleccionar_archivos():
    """
    Pide al usuario subir archivos (Excel o CSV) en Google Colab.
    """
    print("--- PASO 1: SUBIDA DE DATOS ---")
    print("Por favor, sube tus archivos (2023, 2024, 2025...).")
    uploaded = files.upload()
    
    rutas_archivos = []
    for filename, content in uploaded.items():
        # Guardamos el archivo temporalmente
        with open(filename, 'wb') as f:
            f.write(content)
        rutas_archivos.append(filename)
        
    return rutas_archivos

def leer_archivo_robusto(ruta):
    """
    Intenta leer el archivo probando diferentes formatos (Excel, CSV con punto y coma, etc.)
    """
    ext = os.path.splitext(ruta)[1].lower()
    
    try:
        if ext == '.xlsx':
            return pd.read_excel(ruta)
        elif ext == '.csv':
            # Intento 1: CSV estándar (separado por comas)
            try:
                return pd.read_csv(ruta)
            except:
                pass
            # Intento 2: Formato Español (separador ; y decimal ,)
            return pd.read_csv(ruta, sep=';', decimal=',')
    except Exception as e:
        print(f"Error leyendo {ruta}: {e}")
        return None

def normalizar_columnas(df):
    """
    Busca columnas clave (Fecha, Precio, Ocupacion) aunque tengan nombres distintos
    y las renombra al estándar interno.
    """
    # Mapa de posibles nombres -> Nombre Estándar
    mapa = {
        'fecha': 'Fecha', 'date': 'Fecha', 'day': 'Fecha',
        'precio': 'Precio', 'adr': 'Precio', 'price': 'Precio', 'pvn': 'Precio',
        'ocupacion': 'Ocupacion', 'occ': 'Ocupacion', 'ocupación': 'Ocupacion', '% ocupacion': 'Ocupacion'
    }
    
    # Normalizar nombres del DF a minúsculas para buscar
    df.columns = [c.strip().lower() for c in df.columns]
    
    nuevo_mapa = {}
    for col in df.columns:
        for clave, valor in mapa.items():
            if clave in col:
                nuevo_mapa[col] = valor
                break
    
    if nuevo_mapa:
        df = df.rename(columns=nuevo_mapa)
    
    return df

def cargar_datos_seleccionados(rutas_archivos):
    lista_dfs = []
    if not rutas_archivos: return None

    print(f"\nProcesando {len(rutas_archivos)} archivos...")
    
    for archivo in rutas_archivos:
        df = leer_archivo_robusto(archivo)
        
        if df is not None:
            df = normalizar_columnas(df)
            
            # Verificar si tenemos las columnas necesarias
            if {'Fecha', 'Precio', 'Ocupacion'}.issubset(df.columns):
                # Limpieza de valores numéricos (por si vienen como texto con '€' o '%')
                for col in ['Precio', 'Ocupacion']:
                    if df[col].dtype == object:
                        df[col] = df[col].astype(str).str.replace('€', '').str.replace('%', '').str.replace(',', '.')
                        df[col] = pd.to_numeric(df[col], errors='coerce')
                
                lista_dfs.append(df)
                print(f" -> OK: {os.path.basename(archivo)} (Filas: {len(df)})")
            else:
                print(f" -> ERROR: {os.path.basename(archivo)} no tiene las columnas esperadas. Encontradas: {list(df.columns)}")
        
    if not lista_dfs: return None
    
    df_total = pd.concat(lista_dfs, ignore_index=True)
    df_total['Fecha'] = pd.to_datetime(df_total['Fecha'], dayfirst=True) # dayfirst=True para formato europeo
    
    # --- CORRECCIÓN DE PORCENTAJE (Tu problema anterior) ---
    # Rellenar nulos con 0 para evitar errores
    df_total['Ocupacion'] = df_total['Ocupacion'].fillna(0)
    
    max_ocupacion = df_total['Ocupacion'].max()
    if max_ocupacion > 1.5: 
        print(f"\n[AVISO] Normalizando ocupación (Detectado máx: {max_ocupacion}). Dividiendo por 100.")
        df_total['Ocupacion'] = df_total['Ocupacion'] / 100
        
    return df_total

def logica_revenue_manager(precio_base, ocupacion_historica):
    nuevo_precio = precio_base
    accion = "Mantener"
    
    if ocupacion_historica >= 0.90:
        nuevo_precio = precio_base * 1.15 
        accion = "Subida Agresiva (+15%)"
    elif 0.75 <= ocupacion_historica < 0.90:
        nuevo_precio = precio_base * 1.08
        accion = "Subida Moderada (+8%)"
    elif 0.50 <= ocupacion_historica < 0.75:
        nuevo_precio = precio_base * 1.03
        accion = "Ajuste IPC (+3%)"
    elif ocupacion_historica < 0.50:
        nuevo_precio = precio_base * 0.95
        accion = "Bajada Estimulo (-5%)"
        
    return round(nuevo_precio, 2), accion

def generar_proyeccion_2026(df_historico):
    print("\n--- PASO 2: CALCULANDO ESTRATEGIA 2026 ---")
    
    df_historico['MesDia'] = df_historico['Fecha'].dt.strftime('%m-%d')
    
    stats_diarios = df_historico.groupby('MesDia').agg({
        'Precio': 'mean',
        'Ocupacion': 'mean'
    }).reset_index()
    
    # Temporada 2026: 15 mayo - 13 septiembre
    inicio = datetime(2026, 5, 15)
    fin = datetime(2026, 9, 13)
    dias_totales = (fin - inicio).days + 1
    
    proyeccion = []
    
    for i in range(dias_totales):
        fecha_actual = inicio + timedelta(days=i)
        mes_dia_actual = fecha_actual.strftime('%m-%d')
        
        datos_dia = stats_diarios[stats_diarios['MesDia'] == mes_dia_actual]
        
        if not datos_dia.empty:
            adr_hist = datos_dia.iloc[0]['Precio']
            occ_hist = datos_dia.iloc[0]['Ocupacion']
            
            precio_optimo, accion = logica_revenue_manager(adr_hist, occ_hist)
            
            proyeccion.append({
                'Fecha': fecha_actual,
                'Fecha Texto': fecha_actual.strftime('%Y-%m-%d'),
                'Día': fecha_actual.strftime('%A'),
                'ADR Histórico': round(adr_hist, 2),
                'Ocupación Histórica %': round(occ_hist * 100, 1),
                'Precio Recomendado': precio_optimo,
                'Estrategia': accion
            })
    
    return pd.DataFrame(proyeccion)

def visualizar_estrategia(df):
    print("\n--- PASO 3: GENERANDO GRÁFICO ---")
    plt.figure(figsize=(12, 6))
    plt.plot(df['Fecha'], df['ADR Histórico'], label='Histórico', color='gray', linestyle='--', alpha=0.7)
    plt.plot(df['Fecha'], df['Precio Recomendado'], label='Proyección 2026', color='#007acc', linewidth=2.5)
    
    plt.title('Estrategia de Precios Platja Brava 2026', fontsize=14)
    plt.ylabel('Precio (€)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

# --- EJECUCIÓN ---
if __name__ == "__main__":
    rutas = seleccionar_archivos()
    if rutas:
        df_historia = cargar_datos_seleccionados(rutas)
        if df_historia is not None:
            df_final = generar_proyeccion_2026(df_historia)
            
            visualizar_estrategia(df_final)
            
            nombre_salida = 'PlatjaBrava_Estrategia_2026.xlsx'
            df_final.drop(columns=['Fecha']).to_excel(nombre_salida, index=False)
            print(f"\n¡LISTO! Archivo guardado: {nombre_salida}")
            files.download(nombre_salida)
        else:
            print("No se pudieron procesar los archivos. Revisa el formato.")